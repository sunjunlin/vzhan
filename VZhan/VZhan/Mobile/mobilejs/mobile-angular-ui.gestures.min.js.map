{"version":3,"sources":["drag.js","swipe.js","touch.js","transform.js"],"names":[],"mappings":"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","file":"mobile-angular-ui.gestures.min.js","sourcesContent":["/**\n@module mobile-angular-ui.gestures.drag\n@description\n\n`mobile-angular-ui.gestures.drag` module exposes the `$drag` service that is used \nto handle drag gestures. `$drag` service wraps [$touch](../module:touch) service adding\nCSS transforms reacting to `touchmove` events.\n\n## Usage\n\n``` js\nangular.module('myApp', ['mobile-angular-ui.gestures']);\n```\n\nOr\n\n``` js\nangular.module('myApp', ['mobile-angular-ui.gestures.drag']);\n```\n\n``` js\nvar dragOptions = {\n  transform: $drag.TRANSLATE_BOTH,\n  start:  function(dragInfo, event){},\n  end:    function(dragInfo, event){},\n  move:   function(dragInfo, event){},\n  cancel: function(dragInfo, event){}\n};\n\n$drag.bind(element, dragOptions, touchOptions);\n```\n\nWhere:\n\n- `transform` is a `function(element, currentTransform, touch) -> newTransform`\n   returning taking an `element`, its `currentTransform` and returning the `newTransform` \n   for the element in response to `touch`. See [$transform](../module:transform) for more.\n   Default to `$drag.TRANSLATE_BOTH`.\n- `start`, `end`, `move`, `cancel` are optional callbacks responding to `drag` movement phases.\n- `dragInfo` is an extended version of `touchInfo` from [$touch](../module:touch), \n  extending it with:\n  - `originalTransform`: The [$transform](../module:transform) object relative to CSS transform before `$drag` is bound.\n  - `originalRect`: The [Bounding Client Rect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect) for bound element before any drag action.\n  - `startRect`: The [Bounding Client Rect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect) for bound element registered at `start` event.\n  - `startTransform`: The [$transform](../module:transform) at `start` event.\n  - `rect`: The current [Bounding Client Rect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect) for bound element.\n  - `transform`: The current [$transform](../module:transform).\n  - `reset`: A function restoring element to `originalTransform`.\n  - `undo`: A function restoring element to `startTransform`.\n- `touchOptions` is an option object to be passed to underlying [`$touch`](../module:touch) service.\n\n### Predefined transforms\n\n- `$drag.NULL_TRANSFORM`: No transform follow movement\n- `$drag.TRANSLATE_BOTH`: Transform translate following movement on both x and y axis.\n- `$drag.TRANSLATE_HORIZONTAL`: Transform translate following movement on x axis.\n- `$drag.TRANSLATE_UP`: Transform translate following movement on negative y axis.\n- `$drag.TRANSLATE_DOWN`: Transform translate following movement on positive y axis.\n- `$drag.TRANSLATE_LEFT`: Transform translate following movement on negative x axis.\n- `$drag.TRANSLATE_RIGHT`: Transform translate following movement on positive x axis.\n- `$drag.TRANSLATE_VERTICAL`: Transform translate following movement on y axis.\n- `$drag.TRANSLATE_INSIDE`: Is a function and should be used like:\n   \n   ``` js\n    { \n      transform: $drag.TRANSLATE_INSIDE(myElement)\n    }\n   ```\n\n   It returns a transform function that contains translate movement inside \n   the passed element. \n\n### `.ui-drag-move` style\n\nWhile moving an `.ui-drag-move` class is attached to element. Style for this class is defined via\n[insertRule](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet.insertRule) and aims to\nfix common problems while dragging, specifically:\n\n- Brings the element in front of other elements\n- Disable transitions\n- Makes text unselectable\n\n**NOTE** Transitions are disabled cause they may introduce conflicts between `transition: transform` \n and `dragOptions.transform` function.\n\nThey will be re-enabled after drag, and this can be used to achieve some graceful effects.\n\nIf you need transition that does not involve transforms during movement you can apply them to an\ninner or wrapping element. \n\n### Examples\n\n#### Limit movement to an element\n\n``` js\napp.directive('dragMe', ['$drag', function($drag){\n  return {\n    controller: function($scope, $element) {\n      $drag.bind($element, \n        {\n          transform: $drag.TRANSLATE_INSIDE($element.parent()),\n          end: function(drag) {\n            drag.reset();\n          }\n        },\n        { // release touch when movement is outside bounduaries\n          sensitiveArea: $element.parent()\n        }\n      );\n    }\n  };\n}]);\n```\n\n<iframe class='embedded-example' src='/examples/drag.html'></iframe>\n*/\n(function () {\n   'use strict';\n\n   angular.module('mobile-angular-ui.gestures.drag', [\n     'mobile-angular-ui.gestures.touch',\n     'mobile-angular-ui.gestures.transform'\n   ])\n\n  .provider('$drag', function() {\n    this.$get = ['$touch', '$transform', function($touch, $transform) {\n\n      // Add some css rules to be used while moving elements\n      var style = document.createElement('style');\n      style.appendChild(document.createTextNode(''));\n      document.head.appendChild(style);\n      var sheet = style.sheet;\n\n      // Makes z-index 99999\n      sheet.insertRule('html .ui-drag-move{z-index: 99999 !important;}', 0);\n      // Disable transitions\n      sheet.insertRule('html .ui-drag-move{-webkit-transition: none !important;-moz-transition: none !important;-o-transition: none !important;-ms-transition: none !important;transition: none !important;}', 0);\n      // Makes text unselectable\n      sheet.insertRule('html .ui-drag-move, html .ui-drag-move *{-webkit-touch-callout: none !important;-webkit-user-select: none !important;-khtml-user-select: none !important;-moz-user-select: none !important;-ms-user-select: none !important;user-select: none !important;}', 0);\n\n      style = sheet = null;   // we wont use them anymore so make \n                             // their memory immediately claimable\n\n      return {\n\n        // \n        // built-in transforms\n        // \n        NULL_TRANSFORM: function(element, transform) {\n          return transform;\n        },\n\n        TRANSLATE_BOTH: function(element, transform, touch) {\n          transform.translateX = touch.distanceX;\n          transform.translateY = touch.distanceY;\n          return transform;\n        },\n\n        TRANSLATE_HORIZONTAL: function(element, transform, touch) {\n          transform.translateX = touch.distanceX;\n          transform.translateY = 0;\n          return transform;\n        },\n\n        TRANSLATE_UP: function(element, transform, touch) {\n          transform.translateY = touch.distanceY <= 0 ? touch.distanceY : 0;\n          transform.translateX = 0;\n          return transform;\n        },\n\n        TRANSLATE_DOWN: function(element, transform, touch) {\n          transform.translateY = touch.distanceY >= 0 ? touch.distanceY : 0;\n          transform.translateX = 0;\n          return transform;\n        },\n\n        TRANSLATE_LEFT: function(element, transform, touch) {\n          transform.translateX = touch.distanceX <= 0 ? touch.distanceX : 0;\n          transform.translateY = 0;\n          return transform;\n        },\n\n        TRANSLATE_RIGHT: function(element, transform, touch) {\n          transform.translateX = touch.distanceX >= 0 ? touch.distanceX : 0;\n          transform.translateY = 0;\n          return transform;\n        },\n\n        TRANSLATE_VERTICAL: function(element, transform, touch) {\n          transform.translateX = 0;\n          transform.translateY = touch.distanceY;\n          return transform;\n        },\n\n        TRANSLATE_INSIDE: function(wrapperElementOrRectangle) {\n          wrapperElementOrRectangle = wrapperElementOrRectangle.length ? wrapperElementOrRectangle[0] : wrapperElementOrRectangle;\n          \n          return function(element, transform, touch) {\n            element = element.length ? element[0] : element;\n            var re = element.getBoundingClientRect();\n            var rw = wrapperElementOrRectangle instanceof Element ? wrapperElementOrRectangle.getBoundingClientRect() : wrapperElementOrRectangle;\n            var tx, ty;\n\n            if (re.width >= rw.width) {\n              tx = 0;   \n            } else {\n              // compute translateX so that re.left and re.right will stay between rw.left and rw.right\n              if (re.right + touch.stepX > rw.right) {\n                tx = rw.right - re.right;\n              } else if (re.left + touch.stepX < rw.left) {\n                tx = rw.left - re.left;\n              } else {\n                tx = touch.stepX;\n              }\n\n            }\n\n            if (re.height >= rw.height) {\n              ty = 0;   \n            } else {\n              if (re.bottom + touch.stepY > rw.bottom) {\n                ty = rw.bottom - re.bottom;\n              } else if (re.top + touch.stepY < rw.top) {\n                ty = rw.top - re.top;\n              } else {\n                ty = touch.stepY;\n              }\n            }\n\n            transform.translateX += tx;\n            transform.translateY += ty;\n            return transform;\n          };\n        },\n\n        // \n        // bind function\n        // \n        bind: function($element, dragOptions, touchOptions) {\n          $element = angular.element($element);\n          dragOptions = dragOptions || {};\n          touchOptions = touchOptions || {};\n          \n          var startEventHandler = dragOptions.start,\n              endEventHandler = dragOptions.end,\n              moveEventHandler = dragOptions.move,\n              cancelEventHandler = dragOptions.cancel,\n              transformEventHandler = dragOptions.transform || this.TRANSLATE_BOTH;\n\n          var domElement = $element[0],\n              tO = $transform.get($element), // original transform\n              rO = domElement.getBoundingClientRect(), // original bounding rect\n              tS, // transform at start\n              rS;\n\n            var moving = false;\n            \n            var isMoving = function() {\n              return moving;\n            };\n            \n            var cleanup = function() {\n              moving = false;\n              tS = rS = null;\n              $element.removeClass('ui-drag-move');\n            };\n            \n            var reset = function() {\n              $transform.set(domElement, tO);\n            };\n\n            var undo = function() {\n              $transform.set(domElement, tS || tO);\n            };\n\n            var setup = function() {\n              moving = true;\n              rS = domElement.getBoundingClientRect();\n              tS = $transform.get(domElement);\n              $element.addClass('ui-drag-move');\n            };\n\n            var createDragInfo = function(touch) {\n              touch = angular.extend({}, touch);\n              touch.originalTransform = tO;\n              touch.originalRect = rO;\n              touch.startRect = rS;\n              touch.rect = domElement.getBoundingClientRect();\n              touch.startTransform = tS;\n              touch.transform = $transform.get(domElement);\n              touch.reset = reset;\n              touch.undo = undo;\n              return touch;\n            };\n\n            var onTouchMove = function(touch, event) {\n              // preventDefault no matter what \n              // it is (ie. maybe html5 drag for images or scroll)\n              event.preventDefault();\n\n              // $touch calls start on the first touch\n              // to ensure $drag.start is called only while actually\n              // dragging and not for touches we will bind $drag.start\n              // to the first time move is called\n              \n              if (!isMoving()) { // drag start\n                setup();\n                if (startEventHandler) {\n                  startEventHandler(createDragInfo(touch), event);\n                }\n              } else { // drag move\n                touch = createDragInfo(touch);\n\n                var transform = transformEventHandler($element, angular.extend({}, touch.transform), touch, event);\n\n                $transform.set(domElement, transform);\n\n                if (moveEventHandler) {\n                  moveEventHandler(touch, event);\n                }\n              }\n            };\n\n            var onTouchEnd = function(touch, event) {\n              if (!isMoving()) { return; }\n\n              // prevents outer swipes\n              event.__UiSwipeHandled__ = true;\n              \n              touch = createDragInfo(touch);\n              cleanup();\n\n              if (endEventHandler) {\n                endEventHandler(touch, event);\n              }\n            };\n\n            var onTouchCancel = function(touch, event) {\n              if (!isMoving()) { return; }\n              \n              touch = createDragInfo(touch);\n              undo(); // on cancel movement is undoed automatically;\n              cleanup();\n\n              if (cancelEventHandler) {\n                cancelEventHandler(touch, event);\n              }\n            };\n\n            return $touch.bind($element, \n              {move: onTouchMove, end: onTouchEnd, cancel: onTouchCancel},\n              touchOptions);\n          } // ~ bind\n        }; // ~ return $drag\n      }]; // ~ $get\n  });\n\n}());","/**\n * A module providing swipe gesture services and directives.\n * \n * @module mobile-angular-ui.gestures.swipe \n */\n(function() {\n  'use strict';\n\n  var module = angular.module('mobile-angular-ui.gestures.swipe', \n    ['mobile-angular-ui.gestures.touch']);\n\n  /**\n   * An adaptation of `ngTouch.$swipe`, it is basically the same despite of:\n   * \n   * - It is based on [$touch](../module:touch)\n   * - Swipes are recognized by touch velocity and direction\n   * - It does not require `ngTouch` thus is better compatible with fastclick.js \n   * - Swipe directives are nestable\n   * - It allows to unbind\n   * - It has only one difference in interface, and its about how to pass `pointerTypes`:\n   * \n   *   ``` js\n   *     // ngTouch.$swipe\n   *     $swipe.bind(..., ['mouse', ... }); \n   * \n   *     // mobile-angular-ui.gestures.swipe.$swipe\n   *     $swipe.bind(..., pointerTypes: { mouse: { start: 'mousedown', ...} });\n   *   ```\n   *   This is due to the fact that the second parameter of `$swipe.bind` is destinated to options for\n   *   underlying `$touch` service.\n   *   \n   * @service $swipe\n   * @as class\n   */\n  module.factory('$swipe', ['$touch', function($touch) {\n    var VELOCITY_THRESHOLD = 500; // px/sec\n    var MOVEMENT_THRESHOLD = 10; // px\n    var TURNAROUND_MAX = 10; // px\n    var ANGLE_THRESHOLD = 10; // deg\n    var abs = Math.abs;\n\n    var defaultOptions = {\n      movementThreshold: MOVEMENT_THRESHOLD, // start to consider only if movement \n                                             // exceeded MOVEMENT_THRESHOLD\n      valid: function(t) {\n        var absAngle = abs(t.angle);\n        absAngle = absAngle >= 90 ? absAngle - 90 : absAngle;\n\n        var validDistance = t.total - t.distance <= TURNAROUND_MAX,\n            validAngle = absAngle <= ANGLE_THRESHOLD || absAngle >= 90 - ANGLE_THRESHOLD,\n            validVelocity = t.averageVelocity >= VELOCITY_THRESHOLD;\n        \n        return validDistance && validAngle && validVelocity;\n      }\n    };\n\n    return {\n      /**\n       * Bind swipe gesture handlers for an element.\n       *\n       * ``` js\n       * var unbind = $swipe.bind(elem, { \n       *   end: function(touch) { \n       *     console.log('Swiped:', touch.direction);\n       *     unbind();\n       *   }\n       * });\n       * ```\n       * \n       * **Swipes Detection**\n       *\n       * Before consider a touch to be a swipe Mobile Angular UI verifies that:\n       *\n       * 1. Movement is quick. Average touch velocity should exceed a `VELOCITY_THRESHOLD`.\n       * 2. Movement is linear.\n       * 3. Movement has a clear, non-ambiguous direction. So we can assume without error\n       *    that underlying `touch.direction` is exactly the swipe direction. For that\n       *    movement is checked against an `ANGLE_THRESHOLD`.\n       * \n       * @param  {Element|$element} element The element to observe for swipe gestures.\n       * @param  {object} eventHandlers An object with handlers for specific swipe events.\n       * @param  {function} [eventHandlers.start]  The callback for swipe start event.\n       * @param  {function} [eventHandlers.end]  The callback for swipe end event.\n       * @param  {function} [eventHandlers.move]  The callback for swipe move event.\n       * @param  {function} [eventHandlers.cancel]  The callback for swipe cancel event.\n       * @param  {object} [options] Options to be passed to underlying [$touch.bind](../module:touch) function.\n       * \n       * @returns {function} The unbind function.\n       * \n       * @method bind\n       * @memberOf mobile-angular-ui.gestures.swipe~$swipe\n       */\n      bind: function(element, eventHandlers, options) {\n        options = angular.extend({}, defaultOptions, options || {});\n        return $touch.bind(element, eventHandlers, options);\n      }\n    };\n  }]);\n  \n  /**\n   * Specify custom behavior when an element is swiped to the left on a touchscreen device. \n   * A leftward swipe is a quick, right-to-left slide of the finger.\n   * \n   * @directive uiSwipeLeft\n   * @param {expression} uiSwipeLeft An expression to be evaluated on leftward swipe.\n   */\n  /**\n   * Specify custom behavior when an element is swiped to the right on a touchscreen device. \n   * A rightward swipe is a quick, left-to-right slide of the finger.\n   * \n   * @directive uiSwipeRight\n   * @param {expression} uiSwipeRight An expression to be evaluated on rightward swipe.\n   */\n  /**\n   * Alias for [uiSwipeLeft](#uiswipeleft).\n   * \n   * @directive ngSwipeLeft\n   * @deprecated\n   */\n  /**\n   * Alias for [uiSwipeRight](#uiswiperight).\n   * \n   * @directive ngSwipeRight\n   * @deprecated\n   */\n  angular.forEach(['ui', 'ng'], function(prefix) {\n    angular.forEach(['Left', 'Right'], function(direction) {\n      var directiveName = prefix + 'Swipe' + direction;\n      module.directive(directiveName, ['$swipe', '$parse', function($swipe, $parse){\n        return {\n          link: function(scope, elem, attrs) {\n            var onSwipe = $parse(attrs[directiveName]);\n            $swipe.bind(elem, {\n              end: function(swipe, event) {\n                if (swipe.direction === direction.toUpperCase()) {\n                  if (!event.__UiSwipeHandled__) {\n                    event.__UiSwipeHandled__ = true;\n                    scope.$apply(function() {\n                      onSwipe(scope, {$touch: swipe});\n                    });\n                  }\n                }\n              }\n            });\n          }\n        };\n      }]);\n    });\n  });\n}());","/**\n * Device agnostic touch handling.\n *\n * **Usage**\n *\n * Require this module doing either\n *\n * ``` js\n * angular.module('myApp', ['mobile-angular-ui.gestures']);\n * ```\n *\n * Or standalone\n *\n * ``` js\n * angular.module('myApp', ['mobile-angular-ui.gestures.touch']);\n * ```\n * \n * Then you will be able to use the `$touch` service like that:\n * \n * ``` js\n * var unbindFn = $touch.bind(element, {\n *    start: function(touchInfo, e);\n *    move: function(touchInfo, e);\n *    end: function(touchInfo, e);\n *    cancel: function(touchInfo, e);\n * }, options);\n * ```\n * \n * @module mobile-angular-ui.gestures.touch\n */\n(function() {\n  'use strict';\n  var module = angular.module('mobile-angular-ui.gestures.touch', []);\n\n  /** \n   * `$touch` is an abstraction of touch event handling that works with \n   * any kind of input devices.\n   * \n   * It is intended for single touch only and provides \n   * extended infos about touch like: movement, direction, velocity, duration, and more.\n   * $touch service is intended as base to build any single-touch gesture handlers.\n   * \n   * **Usage**\n   * \n   * ``` js\n   * var unbindFn = $touch.bind(element, {\n   *    start: function(touchInfo, e);\n   *    move: function(touchInfo, e);\n   *    end: function(touchInfo, e);\n   *    cancel: function(touchInfo, e);\n   * }, options);\n   * ```\n   * \n   * @service $touch\n   * @as class\n   */\n  \n\n  /**\n   * Configurable provider for `$touch` service\n   * @class  $touchProvider\n   * @ngdoc  provider\n   * @memberOf mobile-angular-ui.gestures.touch~$touch\n   */\n  module.provider('$touch', function() {\n\n    /*=====================================\n    =            Configuration            =\n    =====================================*/\n\n    var VALID = function() {\n      return true;\n    };\n    \n    var MOVEMENT_THRESHOLD = 1;\n\n    var POINTER_EVENTS = {\n      'mouse': {\n        start: 'mousedown',\n        move: 'mousemove',\n        end: 'mouseup'\n      },\n      'touch': {\n        start: 'touchstart',\n        move: 'touchmove',\n        end: 'touchend',\n        cancel: 'touchcancel'\n      }\n    };\n\n    var POINTER_TYPES = ['mouse', 'touch'];\n\n    // function or element or rect\n    var SENSITIVE_AREA = function($element) {\n      return $element[0].ownerDocument.documentElement.getBoundingClientRect();\n    };\n\n    /**\n     * Set default pointer events option.\n     * Pointer Events option specifies a device-by-device map between device specific events and\n     * touch events. \n     *\n     * The default Pointer Events Map is defined as:\n     *\n     * ``` js\n     * var POINTER_EVENTS = {\n     *   'mouse': {\n     *     start: 'mousedown',\n     *     move: 'mousemove',\n     *     end: 'mouseup'\n     *   },\n     *   'touch': {\n     *     start: 'touchstart',\n     *     move: 'touchmove',\n     *     end: 'touchend',\n     *     cancel: 'touchcancel'\n     *   }\n     * };\n     * ```\n     * \n     * Ie.\n     *\n     * ```\n     * app.config(function($touchProvider){\n     *   $touchProvider.setPointerEvents({ pen: {start: \"pendown\", end: \"penup\", move: \"penmove\" }});\n     * });\n     * ```\n     *\n     * @name setPointerEvents\n     * @param {object} pointerEvents The pointer events map object\n     * @memberOf mobile-angular-ui.gestures.touch~$touch.$touchProvider\n     */\n    this.setPointerEvents = function(pointerEvents) {\n      POINTER_EVENTS = pointerEvents;\n      POINTER_TYPES = Object.keys(POINTER_EVENTS);\n    };\n\n    /**\n     * Set default validity function for a touch.\n     * \n     * The default is defined as always true:\n     *\n     * ``` js\n     * $touchProvider.setValid(function(touch, event) {\n     *   return true;\n     * });\n     * ```\n     * \n     * @param {function} validityFunction The validity function. A function that takes two \n     *                   arguments: `touchInfo` and `event`, and returns\n     *                   a `Boolean` indicating wether the corresponding touch\n     *                   should be considered valid and its handlers triggered, \n     *                   or considered invalid and its handlers be ignored.                  \n     * @method setValid\n     * @memberOf mobile-angular-ui.gestures.touch~$touch.$touchProvider\n     */\n    this.setValid = function(fn) {\n      VALID = fn;\n    };\n\n    /**\n     * Set default amount of pixels of movement before\n     * start to trigger `touchmove` handlers.\n     *\n     * Default is `1`.\n     *\n     * ie.\n     * \n     * ``` js\n     * $touchProvider.setMovementThreshold(120);\n     * ```\n     * \n     * @param {integer}  threshold The new treeshold.\n     * \n     * @method  setMovementThreshold\n     * @memberOf mobile-angular-ui.gestures.touch~$touch.$touchProvider\n     */\n    this.setMovementThreshold = function(v) {\n      MOVEMENT_THRESHOLD = v;\n    };\n    /**\n     * Set default sensitive area.\n     *\n     * The sensitive area of a touch is the area of the screen inside what \n     * we consider a touch to be meaningful thus triggering its handlers.\n     *\n     * **NOTE:** if movement goes out the sensitive area the touch event is not cancelled,\n     * instead its handler are just ignored. \n     * \n     * By default sensitive area is defined as `ownerDocument` bounding rectangle \n     * of the bound element.\n     *\n     * ie.\n     * \n     * ``` js\n     * $touchProvider.setSensitiveArea(function($element) {\n     *   return $element[0].ownerDocument.documentElement.getBoundingClientRect();\n     * });\n     * ```\n     * \n     * @param {function|Element|TextRectangle} sensitiveArea The new default sensitive area, \n     *                                                       either static or as function \n     *                                                       taking an element and returning another\n     *                                                       element or a [rectangle](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect).\n     *\n     * @method  setSensitiveArea\n     * @memberOf mobile-angular-ui.gestures.touch~$touch.$touchProvider\n     */\n    this.setSensitiveArea = function(fnOrElementOrRect) {\n      SENSITIVE_AREA = fnOrElementOrRect;\n    };\n\n    // \n    // Shorthands for minification\n    //\n    var abs = Math.abs,\n        atan2 = Math.atan2,\n        sqrt = Math.sqrt;\n\n    /*===============================\n    =            Helpers            =\n    ===============================*/\n\n    var getCoordinates = function(event) {\n      var touches = event.touches && event.touches.length ? event.touches : [event];\n      var e = (event.changedTouches && event.changedTouches[0]) ||\n          (event.originalEvent && event.originalEvent.changedTouches &&\n              event.originalEvent.changedTouches[0]) ||\n          touches[0].originalEvent || touches[0];\n\n      return {\n        x: e.clientX,\n        y: e.clientY\n      };\n    };\n\n    var getEvents = function(pointerTypes, eventType) {\n      var res = [];\n      angular.forEach(pointerTypes, function(pointerType) {\n        var eventName = POINTER_EVENTS[pointerType][eventType];\n        if (eventName) {\n          res.push(eventName);\n        }\n      });\n      return res.join(' ');\n    };\n\n    var now = function() { \n      return new Date();\n    };\n\n    var timediff = function(t1, t2) {\n      t2 = t2 || now();\n      return abs(t2 - t1);\n    };\n\n    var len = function(x, y) {\n      return sqrt(x*x + y*y);\n    };\n\n    /**\n     * `TouchInfo` is an object containing the following extended informations about any touch \n     * event.\n     * \n     * @property {string} type Normalized event type. Despite of pointer device is always one of `touchstart`, `touchend`, `touchmove`, `touchcancel`.\n     * @property {Date} timestamp The time object corresponding to the moment this touch event happened.\n     * @property {integer} duration The difference between this touch event and the corresponding `touchstart`. \n     * @property {float} startX X coord of related `touchstart`.\n     * @property {float} startY Y coord of related `touchstart`.\n     * @property {float} prevX X coord of previous `touchstart` or `touchmove`.\n     * @property {float} prevY Y coord of previous `touchstart` or `touchmove`.\n     * @property {float} x X coord of this touch event.\n     * @property {float} y Y coord of this touch event.\n     * @property {float} step Distance between `[prevX, prevY]` and `[x, y]` points.\n     * @property {float} stepX Distance between `prevX` and `x`.\n     * @property {float} stepY Distance between `prevY` and `y`.\n     * @property {float} velocity Instantaneous velocity of a touch event in pixels per second.\n     * @property {float} averageVelocity Average velocity of a touch event from its corresponding `touchstart` in pixels per second.\n     * @property {float} distance Distance between `[startX, startY]` and `[x, y]` points.\n     * @property {float} distanceX Distance between `startX` and `x`.\n     * @property {float} distanceY Distance between `startY` and `y`.\n     * @property {float} total Total number of pixels covered by movement, taking account of direction changes and turnarounds.\n     * @property {float} totalX Total number of pixels covered by horizontal movement, taking account of direction changes and turnarounds.\n     * @property {float} totalY Total number of pixels covered by vertical, taking account of direction changes and turnarounds.\n     * @property {string} direction The current prevalent direction for this touch, one of `LEFT`, `RIGHT`, `TOP`, `BOTTOM`.\n     * @property {float} angle Angle in degree between x axis and the vector `[x, y]`, is `null` when no movement happens.\n     * \n     * @class TouchInfo\n     * @ngdoc type\n     * @memberOf mobile-angular-ui.gestures.touch~$touch\n     */\n\n    var buildTouchInfo = function(type, c, t0, tl) {\n      // Compute values for new TouchInfo based on coordinates and previus touches.\n      // - c is coords of new touch\n      // - t0 is first touch: useful to compute duration and distance (how far pointer \n      //                    got from first touch)\n      // - tl is last touch: useful to compute velocity and length (total length of the movement)\n\n      t0 = t0 || {}; \n      tl = tl || {}; \n\n      var // timestamps  \n          ts = now(), ts0 = t0.timestamp || ts, tsl = tl.timestamp || ts0,\n          // coords\n          x = c.x, y = c.y, x0 = t0.x || x, y0 = t0.y || y, xl = tl.x || x0, yl = tl.y || y0,\n          // total movement\n          totalXl = tl.totalX || 0, totalYl = tl.totalY || 0, \n          totalX = totalXl + abs(x - xl), totalY = totalYl + abs(y - yl), \n          total = len(totalX, totalY),\n          // duration\n          duration = timediff(ts, ts0),\n          durationl = timediff(ts, tsl),\n          // distance\n          dxl = x - xl, dyl = y - yl, dl = len(dxl, dyl),\n          dx = x - x0, dy = y - y0, d = len(dx, dy),\n          // velocity (px per second)\n          v = durationl > 0 ? abs(dl / ( durationl / 1000 )) : 0,\n          tv = duration > 0 ? abs(total / (duration / 1000)) : 0,\n          // main direction: 'LEFT', 'RIGHT', 'TOP', 'BOTTOM'\n          dir = abs(dx) > abs(dy) ?\n            (dx < 0 ? 'LEFT' : 'RIGHT'):\n            (dy < 0 ? 'TOP' : 'BOTTOM'),\n          // angle (angle between distance vector and x axis)\n          // angle will be:\n          //  0 for x > 0 and y = 0\n          //  90 for y < 0 and x = 0\n          //  180 for x < 0 and y = 0\n          //  -90 for y > 0 and x = 0\n          //  \n          //              -90°\n          //               |\n          //               |\n          //               |\n          //  180° --------|-------- 0°\n          //               |\n          //               |\n          //               |\n          //              90°\n          //          \n          angle = dx !== 0 || dy !== 0  ? atan2(dy, dx) * (180 / Math.PI) : null;\n          angle = angle === -180 ? 180 : angle;\n\n      return {\n        type: type,\n        timestamp: ts,\n        duration: duration,\n        startX: x0,\n        startY: y0,\n        prevX: xl,\n        prevY: yl,\n        x: c.x,\n        y: c.y,\n\n        step:  dl, // distance from prev\n        stepX: dxl,\n        stepY: dyl,\n\n        velocity: v,\n        averageVelocity: tv,\n        \n        distance: d, // distance from start\n        distanceX: dx,\n        distanceY: dy,\n\n        total: total, // total length of momement,\n                      // considering turnaround\n        totalX: totalX,\n        totalY: totalY,\n        direction: dir,\n        angle: angle\n      };\n    };\n\n    /*======================================\n    =            Factory Method            =\n    ======================================*/\n\n    this.$get = [function() {\n      \n      return {\n        /**\n         *\n         * Bind touch handlers for an element.\n         *\n         * ``` js\n         * var unbind = $touch.bind(elem, { \n         *   end: function(touch) { \n         *     console.log('Avg Speed:', touch.averageVelocity);\n         *     unbind();\n         *   }\n         * });\n         * ```\n         * \n         * @param  {Element|$element} element The element to bound to.\n         * @param  {object} eventHandlers An object with handlers for specific touch events.\n         * @param  {function} [eventHandlers.start]  The callback for `touchstart` event.\n         * @param  {function} [eventHandlers.end]  The callback for `touchend` event.\n         * @param  {function} [eventHandlers.move]  The callback for `touchmove` event.\n         * @param  {function} [eventHandlers.cancel]  The callback for `touchcancel` event.\n         * @param  {object} [options] Options.\n         * @param  {integer} [options.movementThreshold] Amount of pixels of movement before start to trigger `touchmove` handlers.\n         * @param  {function} [options.valid] Validity function. A `function(TouchInfo, event)⟶boolean` deciding if a touch should be handled or ignored.\n         * @param  {function|Element|TextRectangle} [options.sensitiveArea] A [Bounding Client Rect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect) or an element \n         *                                                                  or a function that takes the bound element and returns one of the previous.\n         *                                                                  Sensitive area define bounduaries to release touch when movement is outside.\n         * @param  {array} [options.pointerTypes] Pointer types to handle. An array of pointer types that is intended to be \n         *                                        a subset of keys from default pointer events map (see `$touchProvider.setPointerEvents`).\n         *\n         * @returns {function} The unbind function.\n         * \n         * @memberOf mobile-angular-ui.gestures.touch~$touch\n         */\n        bind: function($element, eventHandlers, options) {\n\n          // ensure element to be an angular element \n          $element = angular.element($element);\n          \n          options = options || {};\n          // uses default pointer types in case of none passed\n          var pointerTypes = options.pointerTypes || POINTER_TYPES,\n              isValid = options.valid === undefined ? VALID : options.valid,\n              movementThreshold = options.movementThreshold === undefined ? MOVEMENT_THRESHOLD : options.valid,\n              sensitiveArea = options.sensitiveArea === undefined ? SENSITIVE_AREA : options.sensitiveArea;\n\n          var // first and last touch\n              t0, tl,\n              // events\n              startEvents = getEvents(pointerTypes, 'start'),\n              endEvents = getEvents(pointerTypes, 'end'),\n              moveEvents = getEvents(pointerTypes, 'move'),\n              cancelEvents = getEvents(pointerTypes, 'cancel');\n\n          var startEventHandler = eventHandlers.start,\n              endEventHandler = eventHandlers.end,\n              moveEventHandler = eventHandlers.move,\n              cancelEventHandler = eventHandlers.cancel;\n\n          var $movementTarget = angular.element($element[0].ownerDocument);\n\n          var resetTouch = function() {\n            t0 = tl = null;\n            $movementTarget.off(moveEvents, onTouchMove);\n            $movementTarget.off(endEvents, onTouchEnd);\n            if (cancelEvents) { $movementTarget.off(cancelEvents, onTouchCancel); }\n          };\n\n          var isActive = function() {\n            return !!t0;\n          };\n\n          // \n          // Callbacks\n          // \n\n          // on touchstart\n          var onTouchStart = function(event) {\n            // don't handle multi-touch\n            if (event.touches && event.touches.length > 1) { return; } \n            tl = t0 = buildTouchInfo('touchstart', getCoordinates(event));\n            $movementTarget.on(moveEvents, onTouchMove);\n            $movementTarget.on(endEvents, onTouchEnd);\n            if (cancelEvents) { $movementTarget.on(cancelEvents, onTouchCancel); }\n            if (startEventHandler) {\n              startEventHandler(t0, event); \n            }\n          };\n\n          // on touchCancel\n          var onTouchCancel = function(event) {\n            var t = buildTouchInfo('touchcancel', getCoordinates(event), t0, tl);\n            resetTouch();\n            if (cancelEventHandler) {\n              cancelEventHandler(t, event);\n            }\n          };\n\n          // on touchMove\n          var onTouchMove = function(event) {\n            // don't handle multi-touch\n            if (event.touches && event.touches.length > 1) { return; } \n\n            if (!isActive()) { return; }\n            \n            var coords = getCoordinates(event);\n\n            // \n            // wont fire outside sensitive area\n            // \n            var mva = typeof sensitiveArea === 'function' ? sensitiveArea($element) : sensitiveArea;\n            mva = mva.length ? mva[0] : mva;\n            \n            var mvaRect = mva instanceof Element ? mva.getBoundingClientRect() : mva;\n\n            if (coords.x < mvaRect.left || coords.x > mvaRect.right || coords.y < mvaRect.top || coords.y > mvaRect.bottom){ return; }\n\n            var t = buildTouchInfo('touchmove', coords, t0, tl),\n                totalX = t.totalX,\n                totalY = t.totalY;\n\n            tl = t;\n    \n            if (totalX < movementThreshold && totalY < movementThreshold) {\n              return;\n            }\n\n            if (isValid(t, event)) {\n              if (event.cancelable === undefined || event.cancelable) {\n                event.preventDefault();              \n              }\n              if (moveEventHandler) {\n                moveEventHandler(t, event);\n              }\n            }\n          };\n\n          // on touchEnd\n          var onTouchEnd = function(event) {\n            // don't handle multi-touch\n            if (event.touches && event.touches.length > 1) { return; } \n\n            if (!isActive()) { return; }\n            var t = angular.extend({}, tl, {type: 'touchend'});\n            if (isValid(t, event)) {\n              if (event.cancelable === undefined || event.cancelable) {\n                event.preventDefault();              \n              }\n              if (endEventHandler) {\n                setTimeout(function() { // weird workaround to avoid \n                                        // delays with dom manipulations\n                                        // inside the handler\n                  endEventHandler(t, event);\n                }, 0);\n              }\n            }\n            resetTouch();\n          };\n\n          $element.on(startEvents, onTouchStart);\n\n          return function unbind() {\n            if ($element) { // <- wont throw if accidentally called twice\n              $element.off(startEvents, onTouchStart);\n              if (cancelEvents) { $movementTarget.off(cancelEvents, onTouchCancel); }\n              $movementTarget.off(moveEvents, onTouchMove);\n              $movementTarget.off(endEvents, onTouchEnd);\n\n              // Clear all those variables we carried out from `#bind` method scope\n              // to local scope and that we don't have to use anymore\n              $element = $movementTarget = startEvents = cancelEvents = moveEvents = endEvents = onTouchStart = onTouchCancel = onTouchMove = onTouchEnd = pointerTypes = isValid = movementThreshold = sensitiveArea = null;\n            }\n          };\n        }\n      };\n    }];\n  });\n}());","/**\n@module mobile-angular-ui.gestures.transform\n@description\n\n`mobile-angular-ui.gestures.transform` provides the `$transform` service is designed \nwith the specific aim to provide a cross-browser way to interpolate CSS 3d transform \nwithout having to deal with CSS Matrix, and being able to take into account any previous\nunknown transform already applied to an element.\n\n## Usage\n\nRequire this module doing either\n\n``` js\nangular.module('myApp', ['mobile-angular-ui.gestures']);\n```\n\nOr standalone\n\n``` js\nangular.module('myApp', ['mobile-angular-ui.gestures.transform']);\n```\n\nSay we have an element with applyed css: \n\n``` html\n<div class='myelem'></div>\n```\n\n``` css\n.myelem {\n  transform: translate(12px) rotate(20deg);\n}\n```\n\nThen you can use `$transform` like this:\n\n``` js\n  t = $transform.get(e);\n  t.rotationZ += 15;\n  t.translateX += 1;\n  $transform.set(e, t);\n```\n\n### `$transform` service API\n\n#### `$transform.fromCssMatrix(cssMatrixString) -> transform`\n\nReturns a decomposition of the transform matrix `cssMatrixString`. \nNOTE: 2d matrices are translated to 3d matrices before any other operation.\n\n#### `$transform.toCss(decomposedTransform)`\n\nRecompose a css string from `decomposedTransform`. \n\nTransforms are recomposed as a composition of:\n\n``` css\nmatrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, perspective[0], perspective[1], perspective[2], perspective[3])\ntranslate3d(translation[0], translation[1], translation[2])\nrotateX(rotation[0]) rotateY(rotation[1]) rotateZ(rotation[2])\nmatrix3d(1,0,0,0, 0,1,0,0, 0,skew[2],1,0, 0,0,0,1)\nmatrix3d(1,0,0,0, 0,1,0,0, skew[1],0,1,0, 0,0,0,1)\nmatrix3d(1,0,0,0, skew[0],1,0,0, 0,0,1,0, 0,0,0,1)\nscale3d(scale[0], scale[1], scale[2])\n```\n\n#### `$transform.get(e) -> transform`\n\nReturns a decomposition of the transform matrix applied to `e`.\n\n#### `$transform.set(element, transform)`\n\nIf transform is a string just set it for element `element`. Otherwise is considered as a\ndecomposed transform and is recomposed with `$transform.toCss` and then set to element.\n\n### The decomposed transform object\n\nResult of transform matrix decomposition is an object with the following properties:\n\n```\ntranslateX\ntranslateY\ntranslateZ\nperspectiveX\nperspectiveY\nperspectiveZ\nperspectiveW\nscaleX\nscaleY\nscaleZ\nrotateX\nrotateY\nrotateZ\nskewXY\nskewXZ\nskewYZ\n``` \n\n*/\n(function() {\n  'use strict';\n  \n  var module = angular.module('mobile-angular-ui.gestures.transform', []);\n\n  module.factory('$transform', function(){\n\n    /*==============================================================\n    =            Cross-Browser Property Prefix Handling            =\n    ==============================================================*/\n\n    // Cross-Browser style properties\n    var cssPrefix,\n        transformProperty,\n        styleProperty,\n        prefixes = ['', 'webkit', 'Moz', 'O', 'ms'],\n        d = document.createElement('div');\n    \n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      if ( (prefix + 'Perspective') in d.style ) {\n        cssPrefix = (prefix === '' ? '' : '-' + prefix.toLowerCase() + '-');\n        styleProperty = prefix + (prefix === '' ? 'transform' : 'Transform');\n        transformProperty = cssPrefix + 'transform';\n        break;\n      }\n    }\n\n    d = null;\n\n    // return current element transform matrix in a cross-browser way\n    var getElementTransformProperty = function(e) {\n      e = e.length ? e[0] : e;\n      var tr = window\n              .getComputedStyle(e, null)\n              .getPropertyValue(transformProperty);\n      return tr;\n    };\n\n    // set current element transform matrix in a cross-browser way\n    var setElementTransformProperty = function(elem, value) {\n      elem = elem.length ? elem[0] : elem;\n      elem.style[styleProperty] = value;\n    };\n\n    /*======================================================\n    =            Transform Matrix Decomposition            =\n    ======================================================*/\n\n    var SMALL_NUMBER = 1.e-7;\n\n    var rad2deg = function(angle) {\n      return angle * 180 / Math.PI;\n    };\n\n    var sqrt = Math.sqrt,\n        asin = Math.asin,\n        atan2 = Math.atan2,\n        cos = Math.cos,\n        abs = Math.abs,\n        floor = Math.floor;\n\n    var cloneMatrix = function(m) {\n      var res = [[],[],[],[]];\n      for (var i = 0; i < m.length; i++) {\n        for (var j = 0; j < m[i].length; j++) {\n          res[i][j] = m[i][j];\n        }\n      }\n      return res;\n    };\n\n    var determinant2x2 = function(a, b, c, d) {\n       return a * d - b * c;\n    };\n\n    var determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3) {\n      return a1 * determinant2x2(b2, b3, c2, c3) - b1 * determinant2x2(a2, a3, c2, c3) + c1 * determinant2x2(a2, a3, b2, b3);  \n    };\n\n    var determinant4x4 = function(m) {\n      var a1 = m[0][0], b1 = m[0][1], c1 = m[0][2], d1 = m[0][3], a2 = m[1][0], b2 = m[1][1], c2 = m[1][2], d2 = m[1][3], a3 = m[2][0], b3 = m[2][1], c3 = m[2][2], d3 = m[2][3], a4 = m[3][0], b4 = m[3][1], c4 = m[3][2], d4 = m[3][3];\n      return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) - b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) + c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) - d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);\n    };\n\n    var adjoint = function(m) {\n      var res = [[],[],[],[]], a1 = m[0][0], b1 = m[0][1], c1 = m[0][2], d1 = m[0][3], a2 = m[1][0], b2 = m[1][1], c2 = m[1][2], d2 = m[1][3], a3 = m[2][0], b3 = m[2][1], c3 = m[2][2], d3 = m[2][3], a4 = m[3][0], b4 = m[3][1], c4 = m[3][2], d4 = m[3][3];\n\n      res[0][0]  =   determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);\n      res[1][0]  = - determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);\n      res[2][0]  =   determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);\n      res[3][0]  = - determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);\n      res[0][1]  = - determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);\n      res[1][1]  =   determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);\n      res[2][1]  = - determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);\n      res[3][1]  =   determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);\n      res[0][2]  =   determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);\n      res[1][2]  = - determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);\n      res[2][2]  =   determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);\n      res[3][2]  = - determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);\n      res[0][3]  = - determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);\n      res[1][3]  =   determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);\n      res[2][3]  = - determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);\n      res[3][3]  =   determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);\n\n      return res;\n    };\n\n    var inverse = function(m) {\n      var res = adjoint(m),\n          det = determinant4x4(m);\n      if (abs(det) < SMALL_NUMBER) { return false; }\n      \n      for (var i = 0; i < 4; i++) {\n          for (var j = 0; j < 4; j++) {\n              res[i][j] = res[i][j] / det;\n          }\n      }\n      return res;\n    };\n\n    var transposeMatrix4 = function(m) {\n      var res = [[],[],[],[]];\n      for (var i = 0; i < 4; i++) {\n        for (var j = 0; j < 4; j++) {\n          res[i][j] = m[j][i];\n        }\n      }\n      return res;\n    };\n\n    var v4MulPointByMatrix = function(p, m) {\n      var res = [];\n\n      res[0] = (p[0] * m[0][0]) + (p[1] * m[1][0]) +\n                  (p[2] * m[2][0]) + (p[3] * m[3][0]);\n      res[1] = (p[0] * m[0][1]) + (p[1] * m[1][1]) +\n                  (p[2] * m[2][1]) + (p[3] * m[3][1]);\n      res[2] = (p[0] * m[0][2]) + (p[1] * m[1][2]) +\n                  (p[2] * m[2][2]) + (p[3] * m[3][2]);\n      res[3] = (p[0] * m[0][3]) + (p[1] * m[1][3]) +\n                  (p[2] * m[2][3]) + (p[3] * m[3][3]);\n\n      return res;\n    };\n\n    var v3Length = function(a) {\n      return sqrt((a[0] * a[0]) + (a[1] * a[1]) + (a[2] * a[2]));\n    };\n\n    var v3Scale = function(v, desiredLength) {\n      var res = [], len = v3Length(v);\n      if (len !== 0) {\n          var l = desiredLength / len;\n          res[0] *= l;\n          res[1] *= l;\n          res[2] *= l;\n      }\n      return res;\n    };\n\n    var v3Dot = function(a, b){\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    var v3Combine = function(a, b, ascl, bscl) {\n      var res = [];\n      res[0] = (ascl * a[0]) + (bscl * b[0]);\n      res[1] = (ascl * a[1]) + (bscl * b[1]);\n      res[2] = (ascl * a[2]) + (bscl * b[2]);\n      return res;\n    };\n\n    var v3Cross = function(a, b) {\n      var res = [];\n      res[0] = (a[1] * b[2]) - (a[2] * b[1]);\n      res[1] = (a[2] * b[0]) - (a[0] * b[2]);\n      res[2] = (a[0] * b[1]) - (a[1] * b[0]);\n      return res;\n    };\n\n    var decompose = function(mat) {\n      var result = {}, localMatrix = cloneMatrix(mat), i, j;\n      \n      // Normalize the matrix.\n      if (localMatrix[3][3] === 0) {\n        return false;\n      }\n\n      for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n          localMatrix[i][j] /= localMatrix[3][3];\n        }\n      }\n\n      var perspectiveMatrix = cloneMatrix(localMatrix);\n      for (i = 0; i < 3; i++) {\n        perspectiveMatrix[i][3] = 0;\n      }\n      perspectiveMatrix[3][3] = 1;\n\n      if (determinant4x4(perspectiveMatrix) === 0) {\n        return false;\n      }\n\n      // First, isolate perspective.  This is the messiest.\n      if (localMatrix[0][3] !== 0 || localMatrix[1][3] !== 0 || localMatrix[2][3] !== 0) {\n          // rightHandSide is the right hand side of the equation.\n          var rightHandSide = [];\n          rightHandSide[0] = localMatrix[0][3];\n          rightHandSide[1] = localMatrix[1][3];\n          rightHandSide[2] = localMatrix[2][3];\n          rightHandSide[3] = localMatrix[3][3];\n\n          // Solve the equation by inverting perspectiveMatrix and multiplying\n          // rightHandSide by the inverse. (This is the easiest way, not\n          // necessarily the best.)\n          var inversePerspectiveMatrix = inverse(perspectiveMatrix);\n          var transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix);\n          var perspectivePoint = v4MulPointByMatrix(rightHandSide, transposedInversePerspectiveMatrix);\n\n          result.perspectiveX = perspectivePoint[0];\n          result.perspectiveY = perspectivePoint[1];\n          result.perspectiveZ = perspectivePoint[2];\n          result.perspectiveW = perspectivePoint[3];\n          \n          // Clear the perspective partition\n          localMatrix[0][3] = localMatrix[1][3] = localMatrix[2][3] = 0;\n          localMatrix[3][3] = 1;\n      } else {\n          // No perspective.\n          result.perspectiveX = result.perspectiveY = result.perspectiveZ = 0;\n          result.perspectiveW = 1;\n      }\n\n      // Next take care of translation (easy).\n      result.translateX = localMatrix[3][0];\n      localMatrix[3][0] = 0;\n      result.translateY = localMatrix[3][1];\n      localMatrix[3][1] = 0;\n      result.translateZ = localMatrix[3][2];\n      localMatrix[3][2] = 0;\n\n      // Now get scale and shear.\n      var row = [[],[],[]], pdum3;\n      \n      for (i = 0; i < 3; i++) {\n          row[i][0] = localMatrix[i][0];\n          row[i][1] = localMatrix[i][1];\n          row[i][2] = localMatrix[i][2];\n      }\n\n      // Compute X scale factor and normalize first row.\n      result.scaleX = v3Length(row[0]);\n      v3Scale(row[0], 1.0);\n\n      // Compute XY shear factor and make 2nd row orthogonal to 1st.\n      result.skewXY = v3Dot(row[0], row[1]);\n      v3Combine(row[1], row[0], row[1], 1.0, -result.skewXY);\n\n      // Now, compute Y scale and normalize 2nd row.\n      result.scaleY = v3Length(row[1]);\n      v3Scale(row[1], 1.0);\n      result.skewXY /= result.scaleY;\n\n      // Compute XZ and YZ shears, orthogonalize 3rd row.\n      result.skewXZ = v3Dot(row[0], row[2]);\n      v3Combine(row[2], row[0], row[2], 1.0, -result.skewXZ);\n      result.skewYZ = v3Dot(row[1], row[2]);\n      v3Combine(row[2], row[1], row[2], 1.0, -result.skewYZ);\n\n      // Next, get Z scale and normalize 3rd row.\n      result.scaleZ = v3Length(row[2]);\n      v3Scale(row[2], 1.0);\n      result.skewXZ /= result.scaleZ;\n      result.skewYZ /= result.scaleZ;\n      \n      // At this point, the matrix (in rows[]) is orthonormal.\n      // Check for a coordinate system flip.  If the determinant\n      // is -1, then negate the matrix and the scaling factors.\n      pdum3 = v3Cross(row[1], row[2]);\n      \n      if (v3Dot(row[0], pdum3) < 0) {\n          for (i = 0; i < 3; i++) {\n              result.scaleX *= -1;\n              row[i][0] *= -1;\n              row[i][1] *= -1;\n              row[i][2] *= -1;\n          }\n      }\n\n      // Rotation (angles smaller then SMALL_NUMBER are zeroed)\n      result.rotateY = rad2deg(asin(-row[0][2]))  || 0;\n      if (cos(result.rotateY) !== 0) {\n        result.rotateX = rad2deg(atan2(row[1][2], row[2][2]))  || 0;\n        result.rotateZ = rad2deg(atan2(row[0][1], row[0][0]))  || 0;\n      } else {\n        result.rotateX = rad2deg(atan2(-row[2][0], row[1][1])) || 0;\n        result.rotateZ = 0;\n      }\n\n      return result;\n    };\n\n    /*=========================================\n    =            Factory interface            =\n    =========================================*/\n\n    var fCom = function(n, def) {\n      // avoid scientific notation with toFixed\n      var val = (n || def || 0);\n      return '' + val.toFixed(20);\n    };\n\n    var fPx = function(n, def) {\n      return fCom(n, def) + 'px';\n    };\n\n    var fDeg = function(n, def) {\n      return fCom(n, def) + 'deg';\n    };\n\n    return {\n      fromCssMatrix: function(tr) {\n        var M = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];\n\n        // Just returns identity in case no transform is setup for the element\n        if (tr && tr !== 'none') { \n          var elems = tr.split('(')[1].split(')')[0].split(',').map(Number);\n\n          // Is a 2d transform: matrix(a, b, c, d, tx, ty) is a shorthand \n          // for matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1)\n          if (tr.match(/^matrix\\(/)) {\n            M[0][0] = elems[0];\n            M[1][0] = elems[1];\n            M[0][1] = elems[2];\n            M[1][1] = elems[3];\n            M[3][0] = elems[4];\n            M[3][1] = elems[5];\n\n          // Is a 3d transform, set elements by rows\n          } else {\n            for (var i = 0; i < 16; i++) {\n              var row = floor(i / 4),\n                  col = i % 4;\n              M[row][col] = elems[i];\n            }\n          }\n        }\n        return decompose(M);\n      },\n\n      toCss: function(t) {\n        // \n        // Transforms are recomposed as a composition of:\n        // \n        // matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, perspective[0], perspective[1], perspective[2], perspective[3])\n        // translate3d(translation[0], translation[1], translation[2])\n        // rotateX(rotation[0]) rotateY(rotation[1]) rotateZ(rotation[2])\n        // matrix3d(1,0,0,0, 0,1,0,0, 0,skew[2],1,0, 0,0,0,1)\n        // matrix3d(1,0,0,0, 0,1,0,0, skew[1],0,1,0, 0,0,0,1)\n        // matrix3d(1,0,0,0, skew[0],1,0,0, 0,0,1,0, 0,0,0,1)\n        // scale3d(scale[0], scale[1], scale[2])\n        // \n        \n        var perspective = [\n          fCom(t.perspectiveX),\n          fCom(t.perspectiveY),\n          fCom(t.perspectiveZ),\n          fCom(t.perspectiveW, 1)\n        ],\n        translate = [\n          fPx(t.translateX), \n          fPx(t.translateY), \n          fPx(t.translateZ)\n        ],\n        scale = [\n          fCom(t.scaleX), \n          fCom(t.scaleY),\n          fCom(t.scaleZ)\n        ],\n        rotation = [\n          fDeg(t.rotateX),\n          fDeg(t.rotateY),\n          fDeg(t.rotateZ)\n        ],\n        skew = [\n          fCom(t.skewXY),\n          fCom(t.skewXZ),\n          fCom(t.skewYZ)\n        ];\n        \n        return [\n          'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,' + perspective.join(',') + ')',\n          'translate3d(' + translate.join(',') + ')',\n          'rotateX('+ rotation[0] + ') rotateY(' + rotation[1] + ') rotateZ(' + rotation[2] + ')',\n          'matrix3d(1,0,0,0,0,1,0,0,0,' + skew[2] + ',1,0,0,0,0,1)',\n          'matrix3d(1,0,0,0,0,1,0,0,' + skew[1] + ',0,1,0,0,0,0,1)',\n          'matrix3d(1,0,0,0,' + skew[0] + ',1,0,0,0,0,1,0,0,0,0,1)',\n          'scale3d(' + scale.join(',') + ')'\n        ].join(' ');\n      },\n\n      // \n      // Returns a decomposition of the transform matrix applied\n      // to `e`;\n      //  \n      // NOTE: 2d matrices are translated to 3d matrices\n      //       before any other operation.\n      //       \n      get: function(e) {\n        return this.fromCssMatrix(getElementTransformProperty(e));\n      },\n\n      // Recompose a transform from decomposition `t` and apply it to element `e`\n      set: function(e, t) {\n        var str = (typeof t === 'string') ? t : this.toCss(t);\n        setElementTransformProperty(e, str);  \n      }\n    };\n  });\n}());"],"sourceRoot":"/source/"}